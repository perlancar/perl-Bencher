#!perl

# DATE
# VERSION

use 5.010001;
use strict;
use warnings;
use Log::Any::IfLOG '$log';

use Data::Dmp;
use List::MoreUtils qw(uniq);
use Perinci::CmdLine::Any;

our %SPEC;

sub _uniquify_names {
    my $recs = shift;

    my $names = [map {$_->{name}} @{ $recs }];
    if ((grep {!defined} @$names) || scalar(@{[ uniq(@$names) ]}) < @$names) {
        my $i = -1;
        my %seen;
        for my $rec (@$recs) {
            $i++;
            $rec->{name} //= '';
            if ($seen{ $rec->{name} }++ || $rec->{name} eq '') {
                $rec->{name} .= (length($rec->{name}) ? " " : "") . "#$i";
                # XXX actually still doesn't guarantee unique name
            }
        }
    }
}

sub _find_record_by_seq {
    my ($recs, $seq) = @_;

    for my $rec (@$recs) {
        return $rec if $rec->{seq} == $seq;
    }
    undef;
}

sub _filter_records {
    my %args = @_;

    my $recs = $args{records};
    my $include = $args{include};
    my $exclude = $args{exclude};
    my $include_pattern = $args{include_pattern};
    my $exclude_pattern = $args{exclude_pattern};
    my $include_tags = $args{include_tags};
    my $exclude_tags = $args{exclude_tags};

    my $frecs = [];

  REC:
    for my $rec (@$recs) {
        if ($include && @$include) {
            my $included;
          INC:
            for my $inc (@$include) {
                if ($inc =~ /\A\d+\z/) {
                    if ($rec->{seq} == $inc) {
                        $included++;
                        last INC;
                    }
                } else {
                    if ($rec->{name} eq $inc) {
                        $included++;
                        last INC;
                    }
                }
            }
            next REC unless $included;
        }
        if ($exclude && @$exclude) {
            for my $exc (@$exclude) {
                if ($exc =~ /\A\d+\z/) {
                    next REC if $rec->{seq} == $exc;
                } else {
                    next REC if $rec->{name} eq $exc;
                }
            }
        }
        if ($include_pattern) {
            next REC unless $rec->{seq} =~ /$include_pattern/i ||
                $rec->{name} =~ /$include_pattern/i;
        }
        if ($exclude_pattern) {
            next REC if $rec->{seq} =~ /$exclude_pattern/i ||
                $rec->{name} =~ /$exclude_pattern/i;
        }
        if ($include_tags && @$include_tags) {
            my $included;
          INCTAG:
            for my $tag (@$include_tags) {
                if ($tag =~ /&/) {
                    $included = 1;
                    for my $simpletag (split /\s*&\s*/, $tag) {
                        unless (grep {$_ eq $simpletag} @{ $rec->{tags} // [] }) {
                            $included = 0;
                            next REC;
                        }
                    }
                    last INCTAG;
                } else {
                    if (grep {$_ eq $tag} @{ $rec->{tags} // [] }) {
                        $included++;
                        last INCTAG;
                    }
                }
            }
            next REC unless $included;
        }
        if ($exclude_tags && @$exclude_tags) {
          EXCTAG:
            for my $tag (@$exclude_tags) {
                if ($tag =~ /&/) {
                    for my $simpletag (split /\s*&\s*/, $tag) {
                        unless (grep {$_ eq $simpletag} @{ $rec->{tags} // [] }) {
                            next EXCTAG;
                        }
                    }
                    next REC;
                } else {
                    next REC if grep {$_ eq $tag} @{ $rec->{tags} // [] };
                }
            }
        }

        push @$frecs, $rec;
    }

    $frecs;
}

sub _get_scenario {
    my %args = @_;

    my $pargs = $args{parent_args};

    my $scenario;
    if (defined $pargs->{scenario_file}) {
        $scenario = do $pargs->{scenario_file};
    } elsif (defined $pargs->{scenario_module}) {
        my $m = "Bencher::Scenario::$pargs->{scenario_module}"; $m =~ s!/!::!g;
        my $mp = $m; $mp =~ s!::!/!g; $mp .= ".pm";
        require $mp;
        no strict 'refs';
        $scenario = ${"$m\::scenario"};
    } else {
        $scenario = {
            participants => [],
        };
    }

    if ($pargs->{participants}) {
        for (@{ $pargs->{participants} }) {
            push @{ $scenario->{participants} }, $_;
        }
    }
    if ($pargs->{datasets}) {
        $scenario->{datasets} //= [];
        for (@{ $pargs->{datasets} }) {
            push @{ $scenario->{datasets} }, $_;
        }
    }
    $scenario;
}

# parse scenario (extract module names, filter modules, ...)
sub _parse_scenario {
    use experimental 'smartmatch';

    my %args = @_;

    my $unparsed = $args{scenario};
    my $pargs = $args{parent_args};

    my $parsed = {};

    $parsed->{participants} = [];
    $parsed->{on_failure} = $unparsed->{on_failure};
    $parsed->{modules} = [];
    my $i = -1;
    for my $p0 (@{ $unparsed->{participants} }) {
        $i++;
        my $p = { %$p0, seq=>$i };
        $p->{type} //= do {
            if ($p->{cmdline}) {
                'command';
            } else {
                'perl_code';
            }
        };
        if ($p->{fcall_template}) {
            if ($p->{fcall_template} =~ /\A
                                         (\w+(?:::\w+)*)
                                         (::|->)
                                         (\w+)/x) {
                $p->{module}   = $1;
                $p->{function} = $3;
            }
        }

        if ($p->{module}) {
            push @{ $parsed->{modules} }, $p->{module}
                unless $p->{module} ~~ @{ $parsed->{modules} };
        }

        # try to come up with a default name for the participant
        unless (defined($p->{name})) {
            if ($p->{type} eq 'command') {
                my $cmdline = ref($p->{cmdline}) eq 'ARRAY' ?
                    join(" ", $p->{cmdline}) : $p->{cmdline};
                $p->{name} = substr($cmdline, 0, 12);
            } elsif ($p->{type} eq 'perl_code') {
                if ($p->{function}) {
                    $p->{name} = ($p->{module} ? "$p->{module}::" : "").
                        $p->{function};
                } elsif ($p->{module}) {
                    $p->{name} = $p->{module};
                }
            }
        }

        push @{ $parsed->{participants} }, $p;
    } # for each participant

    if ($unparsed->{datasets}) {
        $parsed->{datasets} = [];
        my $i = -1;
        for my $ds0 (@{ $unparsed->{datasets} }) {
            $i++;
            my $ds = { %$ds0, seq=>$i };

            # try to come up with a default name for the dataset
            unless (defined($ds->{name})) {
                if ($ds->{args}) {
                    $ds->{name} = substr(dmp($ds->{args}), 0, 14);
                } elsif ($ds->{argv}) {
                    $ds->{name} = substr(dmp($ds->{argv}), 0, 14);
                }
            }
            push @{ $parsed->{datasets} }, $ds;
        }
    } # for each dataset

    _uniquify_names($parsed->{participants});
    _uniquify_names($parsed->{datasets}) if $parsed->{datasets};

    # filter by include_modules & exclude_modules
    if ($pargs->{include_modules} && @{ $pargs->{include_modules} }) {
        $parsed->{modules} = [grep {
            $_ ~~ @{ $pargs->{include_modules} }
        } @{ $parsed->{modules} }];
        $parsed->{participants} = [grep {
            !defined($_->{module}) || $_->{module} ~~ @{ $pargs->{include_modules} }
        } @{ $parsed->{participants} }];
    }
    if ($pargs->{exclude_modules} && @{ $pargs->{exclude_modules} }) {
        $parsed->{modules} = [grep {
            !($_ ~~ @{ $pargs->{exclude_modules} })
        } @{ $parsed->{modules} }];
        $parsed->{participants} = [grep {
            !defined($_->{module}) || !($_->{module} ~~ @{ $pargs->{exclude_modules} })
        } @{ $parsed->{participants} }];
    }
    if ($pargs->{include_module_pattern}) {
        $parsed->{modules} = [grep {
            $_ =~ qr/$pargs->{include_module_pattern}/i
        } @{ $parsed->{modules} }];
        $parsed->{participants} = [grep {
            !defined($_->{module}) || $_->{module} =~ qr/$pargs->{include_module_pattern}/i
        } @{ $parsed->{participants} }];
    }
    if ($pargs->{exclude_module_pattern}) {
        $parsed->{modules} = [grep {
            $_ !~ qr/$pargs->{exclude_module_pattern}/i
        } @{ $parsed->{modules} }];
        $parsed->{participants} = [grep {
            !defined($_->{module}) || $_->{module} !~ qr/$pargs->{exclude_module_pattern}/i
        } @{ $parsed->{participants} }];
    }

    $parsed->{participants} = _filter_records(
        records => $parsed->{participants},
        include => $pargs->{include_participants},
        exclude => $pargs->{exclude_participants},
        include_pattern => $pargs->{include_participant_pattern},
        exclude_pattern => $pargs->{exclude_participant_pattern},
        include_tags => $pargs->{include_participant_tags},
        exclude_tags => $pargs->{exclude_participant_tags},
    );
    $parsed->{datasets} = _filter_records(
        records => $parsed->{datasets},
        include => $pargs->{include_datasets},
        exclude => $pargs->{exclude_datasets},
        include_pattern => $pargs->{include_dataset_pattern},
        exclude_pattern => $pargs->{exclude_dataset_pattern},
        include_tags => $pargs->{include_dataset_tags},
        exclude_tags => $pargs->{exclude_dataset_tags},
    );

    $parsed;
}

sub _gen_items {
    require Permute::Named::Iter;

    my %args = @_;

    my $parsed = $args{scenario};
    my $pargs  = $args{parent_args};

    $parsed->{items} = [];
    my @permute;

    # XXX allow permutation of perl path
    # XXX allow permutation of module path

    my $participants;
    my $datasets;

    if ($pargs->{module_startup}) {
        return [412, "There are no modules to benchmark ".
                    "the startup overhead of"]
            unless @{$parsed->{modules}};

        {
            # push perl as base-line
            push @$participants, {
                seq  => 0,
                name => "perl -e1 (baseline)",
                type => 'command',
                cmdline => [$^X, "-e1"],
            };

            my $i = 0;
            for my $mod (@{ $parsed->{modules} }) {
                $i++;
                push @$participants, {
                    seq  => $i,
                    name => $mod,
                    type => 'command',
                    cmdline => [$^X, "-M$mod", "-e1"],
                };
            }
        }
    } else {
        return [412, "Please load a scenario (-m, -f) or ".
                    "include at least one participant (-p)"]
            unless @{$parsed->{participants}};
        $participants = $parsed->{participants};
        $datasets = $parsed->{datasets} if $parsed->{datasets};
    }

    push @permute, "participant", [map {$_->{seq}} @$participants];

    if ($datasets) {
        push @permute, "dataset", [map {$_->{seq}} @$datasets];
    }
    $log->debugf("permute: %s", \@permute);

    my $iter = Permute::Named::Iter::permute_named_iter(@permute);
    my $i = -1;
  ITER:
    while (my $h = $iter->()) {
        $log->tracef("iter returns: %s", $h);
        $i++;
        my $item_name;

        my $p = _find_record_by_seq($participants, $h->{participant});
        my $ds;

        if (exists $h->{dataset}) {
            $ds = _find_record_by_seq($datasets, $h->{dataset});
            # filter first
            if ($ds->{include_participant_tags}) {
                my $included = 0;
              INCTAG:
                for my $tag (@{ $ds->{include_participant_tags} }) {
                    if ($tag =~ /\&/) {
                        for my $simpletag (split /\s*&\s*/, $tag) {
                            unless (grep {$simpletag eq $_} @{ $p->{tags} // [] }) {
                                next INCTAG;
                            }
                        }
                        $included++;
                        last INCTAG;
                    } else {
                        if (grep {$tag eq $_} @{ $p->{tags} // [] }) {
                            $included++;
                            last INCTAG;
                        }
                    }
                }
                unless ($included) {
                    $log->tracef(
                        "skipped dataset by include_participant_tags ".
                            "(%s vs participant:%s)",
                        $ds->{include_participant_tags}, $p->{tags});
                    next ITER;
                }
            }
            if ($ds->{exclude_participant_tags}) {
                my $excluded = 0;
              EXCTAG:
                for my $tag (@{ $ds->{exclude_participant_tags} }) {
                    if ($tag =~ /\&/) {
                        for my $simpletag (split /\s*&\s*/, $tag) {
                            unless (grep {$simpletag eq $_} @{ $p->{tags} // [] }) {
                                next EXCTAG;
                            }
                        }
                        $excluded++;
                        last EXCTAG;
                    } else {
                        if (grep {$tag eq $_} @{ $p->{tags} // [] }) {
                            $excluded++;
                            last EXCTAG;
                        }
                    }
                }
                if ($excluded) {
                    $log->tracef(
                        "skipped dataset by exclude_participant_tags ".
                            "(%s vs participant:%s)",
                        $ds->{exclude_participant_tags}, $p->{tags});
                    next ITER;
                }
            }
        }

        {
            # convert participant's & dataset index to name temporarily, for
            # nicer item name
            my %h = %$h;
            $h{participant} = $p->{name};
            $h{dataset} = $ds->{name} if $ds;
            my @k = keys %h;
            if (@k == 1) {
                $item_name = $h{$k[0]};
            } else {
                $item_name = dmp(\%h);
            }
            #$log->tracef("Set item name to: %s", $item_name);
        }

        my $code;
        if ($p->{type} eq 'command') {
            my @cmd;
            my $shell;
            if (ref($p->{cmdline}) eq 'ARRAY') {
                @cmd = @{ $p->{cmdline} };
                $shell = 0;
            } else {
                @cmd = ($p->{cmdline});
                $shell = 1;
            }
            $code = sub {
                if ($shell) {
                    system $cmd[0];
                } else {
                    system {$cmd[0]} @cmd;
                }
                die "Command failed (child error=$?, os error=$!)\n"
                    if $?;
            };
        } elsif ($p->{type} eq 'perl_code') {
            if ($p->{code}) {
                if ($ds) {
                    if ($ds->{argv}) {
                        $code = sub { $p->{code}->(@{$ds->{argv}}) };
                    } elsif ($ds->{args}) {
                        $code = sub { $p->{code}->(%{$ds->{args}}) };
                    } else {
                        return [400, "Participant #$p->{seq}, dataset #$h->{dataset}: No argv/args supplied for code"];
                    }
                } else {
                    $code = $p->{code};
                }
            } elsif (my $template = $p->{code_template} || $p->{fcall_template}) {
                my $template_vars;
                if ($ds->{args}) {
                    $template_vars = $ds->{args};
                } elsif ($ds->{argv}) {
                    $template_vars = { map {$_=>$ds->{argv}[$_]}
                                           @{ $ds->{argv} } };
                } else {
                    warn "Item #$i: participant specifies code_template/fcall_template but there is no args/argv in the dataset #$h->{dataset}\n";
                }

                if ($template_vars) {
                    $template =~ s/\<(\w+)\>/dmp($template_vars->{$1})/eg;
                }
                my $code_str = "sub { $template }";
                $log->debugf("Item #%d: code=%s", $i, $code_str);
                $code = eval $code_str;
                return [400, "Item #$i: code compile error: $@ (code: $code_str)"] if $@;
            }
        } else {
            return [400, "Unknown participant type '$p->{type}'"];
        }

        push @{ $parsed->{items} }, {
            seq  => $i,
            name => $item_name,
            code => $code,
        };
    } # ITER

    $parsed->{items} = _filter_records(
        records => $parsed->{items},
        include => $pargs->{include_items},
        exclude => $pargs->{exclude_items},
        include_pattern => $pargs->{include_item_pattern},
        exclude_pattern => $pargs->{exclude_item_pattern},
    );
    [200];
}

sub _complete_module {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => $parsed->{modules},
    );
}

sub _complete_participant {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => [map {($_->{seq}, $_->{name})} @{$parsed->{participants}}],
    );
}

sub _complete_participant_tags {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);

    my %tags;
    for my $p (@{ $parsed->{participants} }) {
        if ($p->{tags}) {
            $tags{$_}++ for @{ $p->{tags} };
        }
    }

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => [keys %tags],
    );
}

sub _complete_dataset {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => [map {($_->{seq}, $_->{name})} @{$parsed->{datasets}}],
    );
}

sub _complete_dataset_tags {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);

    my %tags;
    for my $p (@{ $parsed->{datasets} }) {
        if ($p->{tags}) {
            $tags{$_}++ for @{ $p->{tags} };
        }
    }

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => [keys %tags],
    );
}

sub _complete_item {
    my %args = @_;
    my $word    = $args{word} // '';
    my $cmdline = $args{cmdline};
    my $r       = $args{r};

    return undef unless $cmdline;

    # force reading config file
    $r->{read_config} = 1;
    my $res = $cmdline->parse_argv($r);

    my $args = $res->[2];
    my $unparsed = _get_scenario(parent_args=>$args);
    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>$args);
    $res = _gen_items(scenario=>$parsed, parent_args=>$args);
    return undef unless $res->[0] == 200;

    require Complete::Util;
    Complete::Util::complete_array_elem(
        word  => $word,
        array => [grep {!/\{/} # remove names that are too unwieldy
                      map {($_->{seq}, $_->{name})} @{$parsed->{items}}],
    );
}

$SPEC{bencher} = {
    v => 1.1,
    summary => 'A benchmark framework',
    args => {
        scenario_file => {
            summary => 'Load a scenario from a Perl file',
            description => <<'_',

Perl file will be do()'ed and the last expression should be a hash containing
the scenario specification.

_
            schema => 'str*',
            cmdline_aliases => {f=>{}},
        },
        scenario_module => {
            summary => 'Load a scenario from a Bencher::Scenario:: Perl module',
            description => <<'_',

Will try to load module `Bencher::Scenario::<NAME>` and expect to find a package
variable in the module called `$scenario` which should be a hashref containing
the scenario specification.

_
            schema => ['str*', match=>qr!\A\w+((?:::|/)\w+)*\z!],
            cmdline_aliases => {m=>{}},
            completion => sub {
                require Complete::Module;
                my %args = @_;
                Complete::Module::complete_module(
                    word=>$args{word}, ns_prefix=>'Bencher::Scenario');
            },
        },
        participants => {
            'summary' => 'Add participants',
            'x.name.is_plural' => 1,
            schema => ['array*', of=>'hash*'],
            cmdline_aliases => {
                p => {
                    summary => 'Add a participant',
                    code => sub {
                        require JSON;

                        my $args = shift;
                        push @{ $args->{participants} },
                            JSON::decode_json($_[0]);
                    },
                }
            },
        },
        datasets => {
            summary => 'Add datasets',
            'x.name.is_plural' => 1,
            schema => ['array*', of=>'hash*'],
            cmdline_aliases => {
                d => {
                    summary => 'Add a dataset',
                    code => sub {
                        require JSON;

                        my $args = shift;
                        push @{ $args->{datasets} },
                            JSON::decode_json($_[0]);
                    },
                },
            },
        },
        action => {
            schema => ['str*', {
                in=>[qw/
                           list-scenario-modules
                           show-scenario
                           list-participants
                           list-participant-modules
                           list-datasets
                           list-items
                           bench
                       /]
                    # list-functions
            }],
            default => 'bench',
            cmdline_aliases => {
                a => {},
                list_scenario_modules => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-scenario-modules',
                    code => sub { $_[0]{action} = 'list-scenario-modules' },
                },
                L => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-scenario-modules',
                    code => sub { $_[0]{action} = 'list-scenario-modules' },
                },
                show_scenario => {
                    is_flag => 1,
                    summary => 'Shortcut for -a show-scenario',
                    code => sub { $_[0]{action} = 'show-scenario' },
                },
                list_participants => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-participants',
                    code => sub { $_[0]{action} = 'list-participants' },
                },
                list_participant_modules => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-participant-modules',
                    code => sub { $_[0]{action} = 'list-participant-modules' },
                },
                list_datasets => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-datasets',
                    code => sub { $_[0]{action} = 'list-datasets' },
                },
                list_items => {
                    is_flag => 1,
                    summary => 'Shortcut for -a list-items',
                    code => sub { $_[0]{action} = 'list-items' },
                },
            },
            tags => ['category:action'],
        },
        module_startup => {
            schema => ['bool*', is=>1],
            summary => 'Benchmark module startup overhead instead of normal benchmark',
            tags => ['category:action'],
        },
        detail => {
            schema => 'bool*',
            cmdline_aliases => {l=>{}},
        },
        time_unit => {
            schema => ['str*', in=>[qw/s ms/]],
            default => 's',
            cmdline_aliases => {
                ms => {
                    is_flag => 1,
                    code => sub { $_[0]{time_unit} = 'ms' },
                    summary => 'Alias for --time-unit=ms',
                },
            },
        },

        include_modules => {
            'x.name.is_plural' => 1,
            summary => 'Only include modules specified in this list',
            'summary.alt.plurality.singular' => 'Add module to include list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_module,
            tags => ['category:filtering'],
        },
        include_module_pattern => {
            summary => 'Only include modules matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },
        exclude_modules => {
            'x.name.is_plural' => 1,
            summary => 'Exclude modules specified in this list',
            'summary.alt.plurality.singular' => 'Add module to exclude list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_module,
            tags => ['category:filtering'],
        },
        exclude_module_pattern => {
            summary => 'Exclude module(s) matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },

        include_participants => {
            'x.name.is_plural' => 1,
            summary => 'Only include participants whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add participant to include list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_participant,
            tags => ['category:filtering'],
        },
        include_participant_pattern => {
            summary => 'Only include participants matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },
        include_participant_tags => {
            'x.name.is_plural' => 1,
            summary => 'Only include participants whose tag matches this',
            'summary.alt.plurality.singular' => 'Add a tag to participants include tag list',
            description => <<'_',

You can specify `A & B` to include participants that have _both_ tags A and B.

_
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_participant_tags,
            tags => ['category:filtering'],
        },
        exclude_participants => {
            'x.name.is_plural' => 1,
            summary => 'Exclude participants whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add participant to include list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_participant,
            tags => ['category:filtering'],
        },
        exclude_participant_pattern => {
            summary => 'Exclude participants matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },
        exclude_participant_tags => {
            'x.name.is_plural' => 1,
            summary => 'Exclude participants whose tag matches this',
            'summary.alt.plurality.singular' => 'Add a tag to participants exclude tag list',
            description => <<'_',

You can specify `A & B` to exclude participants that have _both_ tags A and B.

_
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_participant_tags,
            tags => ['category:filtering'],
        },

        include_items => {
            'x.name.is_plural' => 1,
            summary => 'Only include items whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add item to include list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_item,
            tags => ['category:filtering'],
        },
        include_item_pattern => {
            summary => 'Only include items matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },
        exclude_items => {
            'x.name.is_plural' => 1,
            summary => 'Exclude items whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add item to exclude list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_item,
            tags => ['category:filtering'],
        },
        exclude_item_pattern => {
            summary => 'Exclude items matching this regex pattern',
            schema => ['re*'],
            tags => ['category:filtering'],
        },

        include_datasets => {
            'x.name.is_plural' => 1,
            summary => 'Only include datasets whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add dataset to include list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_dataset,
            tags => ['category:filtering'],
        },
        include_dataset_pattern => {
            summary => 'Only include datasets matching this regex pattern',
            schema => 're*',
            tags => ['category:filtering'],
        },
        exclude_datasets => {
            'x.name.is_plural' => 1,
            summary => 'Exclude datasets whose seq/name matches this',
            'summary.alt.plurality.singular' => 'Add dataset to exclude list',
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_dataset,
            tags => ['category:filtering'],
        },
        exclude_dataset_pattern => {
            summary => 'Exclude datasets matching this regex pattern',
            schema => 're*',
            tags => ['category:filtering'],
        },
        include_dataset_tags => {
            'x.name.is_plural' => 1,
            summary => 'Only include datasets whose tag matches this',
            'summary.alt.plurality.singular' => 'Add a tag to dataset include tag list',
            description => <<'_',

You can specify `A & B` to include datasets that have _both_ tags A and B.

_
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_dataset_tags,
            tags => ['category:filtering'],
        },
        exclude_dataset_tags => {
            'x.name.is_plural' => 1,
            summary => 'Exclude datasets whose tag matches this',
            'summary.alt.plurality.singular' => 'Add a tag to dataset exclude tag list',
            description => <<'_',

You can specify `A & B` to exclude datasets that have _both_ tags A and B.

_
            schema => ['array*', of=>'str*'],
            element_completion => \&_complete_dataset_tags,
            tags => ['category:filtering'],
        },

        on_failure => {
            summary => "What to do when command fails or Perl code dies",
            schema => ['str*', in=>[qw/die skip/]],
            description => <<'_',

The default is "die". When set to "skip", will first run the code of each item
before benchmarking and trap command failure/Perl exception and if that happens,
will "skip" the item.

_
        },
    },
};
sub bencher {
    my %args = @_;

    my $action = $args{action};

    if ($action eq 'list-scenario-modules') {
        require PERLANCAR::Module::List;
        my $mods = PERLANCAR::Module::List::list_modules(
            'Bencher::Scenario::', {list_modules=>1, recurse=>1});
        return [200, "OK",
                [map {s/^Bencher::Scenario:://; $_} sort keys %$mods]];
    }

    my $unparsed = _get_scenario(parent_args=>\%args);

    if ($action eq 'show-scenario') {
        return [200, "OK", $unparsed];
    }

    my $parsed = _parse_scenario(scenario=>$unparsed, parent_args=>\%args);

    if ($action eq 'list-datasets') {
        return [200, "OK", undef] unless $parsed->{datasets};
        my @res;
        my $has_summary = 0;
        for my $ds (@{ $parsed->{datasets} }) {
            if ($args{detail}) {
                my $rec = {
                    seq      => $ds->{seq},
                    name     => $ds->{name},
                    tags     => join(", ", @{ $ds->{tags} // []}),
                };
                if (defined $ds->{summary}) {
                    $has_summary = 1;
                    $rec->{summary} = $ds->{summary};
                }
                push @res, $rec;
            } else {
                push @res, $ds->{name};
            }
        }
        my %resmeta;
        $resmeta{'table.fields'} = [
            'seq',
            'name',
            ('summary') x $has_summary,
            'tags',
        ]
            if $args{detail};
        return [200, "OK", \@res, \%resmeta];
    }

    if ($action eq 'list-participant-modules') {
        return [200, "OK", $parsed->{modules}];
    }

    if ($action eq 'list-participants') {
        my @res;
        my $has_summary = 0;
        for my $p (@{ $parsed->{participants} }) {
            if ($args{detail}) {
                my $rec = {
                    seq      => $p->{seq},
                    type     => $p->{type},
                    name     => $p->{name},
                    function => $p->{function},
                    module   => $p->{module},
                    cmdline  => ref($p->{cmdline}) eq 'ARRAY' ? join(" ", @{$p->{cmdline}}) : $p->{cmdline},
                    tags     => join(", ", @{$p->{tags} // []}),
                };
                if (defined $p->{summary}) {
                    $has_summary = 1;
                    $rec->{summary} = $p->{summary};

                }
                push @res, $rec;
            } else {
                push @res, $p->{name};
            }
        }
        my %resmeta;
        $resmeta{'table.fields'} = [
            'seq',
            'type',
            'name',
            ('summary') x $has_summary,
            'module',
            'function',
            'cmdline',
            'tags',
        ]
            if $args{detail};
        return [200, "OK", \@res, \%resmeta];
    }

    my $res = _gen_items(scenario=>$parsed, parent_args=>\%args);
    return $res unless $res->[0] == 200;

    if ($action eq 'list-items') {
        my @res;
        for my $it (@{ $parsed->{items} }) {
            if ($args{detail}) {
                push @res, {
                    seq      => $it->{seq},
                    name     => $it->{name},
                };
            } else {
                push @res, $it->{name};
            }
        }
        my %resmeta;
        $resmeta{'table.fields'} = [qw/seq name/]
            if $args{detail};
        return [200, "OK", \@res, \%resmeta];
    }

    if ($action eq 'bench') {
        require Benchmark::Dumb;
        require Module::Load;

        for my $mod (@{ $parsed->{modules} }) {
            Module::Load::load($mod);
        }

        my $on_failure = $args{on_failure} // $parsed->{on_failure} // 'die';
        if ($on_failure eq 'skip') {
            my $fitems = [];
            for my $it (@{ $parsed->{items} }) {
                $log->tracef("Testing code for item #%d (%s) ...",
                             $it->{seq}, $it->{name});
                eval { $it->{code}->() };
                if ($@) {
                    warn "Skipping item #$it->{seq} ($it->{name}) ".
                        "due to failure: $@\n";
                    next;
                }
                push @$fitems, $it;
            }
            $parsed->{items} = $fitems;
        }

        my $tres = Benchmark::Dumb::_timethese_guts(
            0,
            {
                map { $_->{seq} => $_->{code} } @{ $parsed->{items} }
            },
            "silent",
        );
        my @res;
        for my $seq (sort {$a<=>$b} keys %$tres) {
            my $it = _find_record_by_seq($parsed->{items}, $seq);
            push @res, {
                seq     => $seq,
                name    => $it->{name},
                time    => $tres->{$seq}{result}{num},
                rate    => 1 / $tres->{$seq}{result}{num},
                samples => $tres->{$seq}{result}{_dbr_nsamples},
                errors  => $tres->{$seq}{result}{errors}[0],
            };
        }

        if ($parsed->{after_bench}) {
            $parsed->{after_bench}->(result => \@res);
        }

        @res = sort {$b->{time} <=> $a->{time}} @res;

        if ($args{time_unit} eq 'ms') {
            for my $res (@res) {
                $res->{time} = sprintf("%10.4fms", $res->{time}*1000);
            }
        }
        my %resmeta;
        $resmeta{'table.fields'} = [qw/seq name rate time samples errors/];
        return [200, "OK", \@res, \%resmeta];
    }

    [304,"No action"];
}

Perinci::CmdLine::Any->new(
    url => '/main/bencher',
    log => 1,
)->run;

# ABSTRACT: A benchmark framework (CLI)
# PODNAME:

=head1 SYNOPSIS

List all scenario modules (Bencher::Scenario::*):

 % bencher --list-scenario-modules
 % bencher -L

Run benchmark described by a scenario module:

 % bencher -m Example

Run benchmark described by a scenario file:

 % bencher -f scenario.pl

Add participants from the command-line instead of (or in addition to) those
specified in a scenario file/module:

 % bencher -p '{"fcall_template":"Bar::func(<arg>)"}'

Run module startup overhead benchmark instead of the normal benchmark:

 % bencher -m Example --module-startup

Show/dump scenario instead of running benchmark:

 % bencher -m Example --show-scenario

List participants instead of running benchmark:

 % bencher ... --list-participants

List datasets instead of running benchmark:

 % bencher ... --list-datasets

List items instead of running benchmark:

 % bencher ... --list-items

Select (include/exclude) participants before running benchmark (you can also
select datasets/modules/items):

 % bencher ... --include-participant-pattern 'Tiny|Lite' --exclude-participant 'HTTP::Tiny'


=head1 DESCRIPTION


=head1 SEE ALSO

L<Bencher>
